{"version":3,"file":"dist/backgroundBundle.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AElTA;AACA;AACA;AACA;AACA","sources":["webpack://phisher-shield-extension/./src/background.ts","webpack://phisher-shield-extension/webpack/before-startup","webpack://phisher-shield-extension/webpack/startup","webpack://phisher-shield-extension/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n// extension/src/background.ts\nconsole.log('PhisherShield background service worker started (Final Fix for AI Cache & WebRequest).');\nvar bypassingTabs = new Set();\nvar SCAN_CACHE_DURATION_MS = 5 * 60 * 1000; // Cache results for 5 minutes\n// Helper function to fetch trust score from your backend\nfunction fetchTrustScoreFromBackend(url_1) {\n    return __awaiter(this, arguments, void 0, function (url, redirectType // Accepts redirectType\n    ) {\n        var response, errorText, data, error_1;\n        if (redirectType === void 0) { redirectType = null; }\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 5, , 6]);\n                    console.log(\"[Background] Attempting to fetch trust score for: \".concat(url, \" (Redirect: \").concat(redirectType || 'None', \")\"));\n                    return [4 /*yield*/, fetch(\"http://localhost:4000/api/trustScore\", {\n                            method: 'POST',\n                            headers: { 'Content-Type': 'application/json' },\n                            // Pass redirectType to backend\n                            body: JSON.stringify({ url: url, content: '', redirectType: redirectType }),\n                        })];\n                case 1:\n                    response = _a.sent();\n                    if (!!response.ok) return [3 /*break*/, 3];\n                    return [4 /*yield*/, response.text()];\n                case 2:\n                    errorText = _a.sent();\n                    console.error(\"[Background] Backend HTTP error for \".concat(url, \": Status \").concat(response.status, \", Message: \").concat(errorText));\n                    return [2 /*return*/, { trustScore: 0, alertMessage: \"Failed to scan site: Server error.\", geminiAiScore: null, geminiAiReason: null }];\n                case 3: return [4 /*yield*/, response.json()];\n                case 4:\n                    data = _a.sent();\n                    console.log(\"[Background] Successfully fetched score for \".concat(url, \":\"), data);\n                    return [2 /*return*/, {\n                            trustScore: data.trustScore,\n                            alertMessage: data.alertMessage,\n                            geminiAiScore: data.geminiAiScore,\n                            geminiAiReason: data.geminiAiReason\n                        }];\n                case 5:\n                    error_1 = _a.sent();\n                    console.error(\"[Background] Network error fetching trust score for \".concat(url, \":\"), error_1);\n                    return [2 /*return*/, { trustScore: 0, alertMessage: \"Failed to scan site: Network error.\", geminiAiScore: null, geminiAiReason: null }];\n                case 6: return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * Attempts to send a message to a tab, retrying if 'Receiving end does not exist' error occurs.\n * @param tabId The ID of the target tab.\n * @param message The message object to send.\n * @param retries Remaining retry attempts.\n * @param delayMs Delay in milliseconds before next retry.\n */\nfunction retrySendMessage(tabId_1, message_1) {\n    return __awaiter(this, arguments, void 0, function (tabId, message, retries, delayMs) {\n        var error_2;\n        if (retries === void 0) { retries = 3; }\n        if (delayMs === void 0) { delayMs = 200; }\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    console.log(\"[Background] Attempting to send message to tab \".concat(tabId, \" (Type: \").concat(message.type, \", Retries left: \").concat(retries, \")\"));\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 3, , 8]);\n                    return [4 /*yield*/, chrome.tabs.sendMessage(tabId, message)];\n                case 2:\n                    _a.sent();\n                    console.log(\"[Background] Successfully sent message to tab \".concat(tabId, \" (Type: \").concat(message.type, \").\"));\n                    return [3 /*break*/, 8];\n                case 3:\n                    error_2 = _a.sent();\n                    if (!(error_2.message && error_2.message.includes('Receiving end does not exist') && retries > 0)) return [3 /*break*/, 6];\n                    console.warn(\"[Background] Retrying message to tab \".concat(tabId, \" (Type: \").concat(message.type, \")... Retries left: \").concat(retries - 1));\n                    return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, delayMs); })];\n                case 4:\n                    _a.sent();\n                    return [4 /*yield*/, retrySendMessage(tabId, message, retries - 1, delayMs * 1.5)];\n                case 5:\n                    _a.sent();\n                    return [3 /*break*/, 7];\n                case 6:\n                    console.error(\"[Background] Failed to send message to tab \".concat(tabId, \" (Type: \").concat(message.type, \"):\"), error_2);\n                    _a.label = 7;\n                case 7: return [3 /*break*/, 8];\n                case 8: return [2 /*return*/];\n            }\n        });\n    });\n}\n// Listener for URL navigation requests (the pre-load check)\nchrome.webRequest.onBeforeRequest.addListener(function (details) {\n    var _this = this;\n    console.log(\"[Background-WebReq] Intercepted: \".concat(details.url, \", Type: \").concat(details.type, \", TabId: \").concat(details.tabId));\n    if (bypassingTabs.has(details.tabId)) {\n        console.log(\"[Background-WebReq] Bypassing scan for tab \".concat(details.tabId, \" (original URL: \").concat(details.url, \") due to 'continue' action.\"));\n        return { cancel: false };\n    }\n    if (details.type === \"main_frame\" &&\n        (details.url.startsWith(\"http://\") || details.url.startsWith(\"https://\")) &&\n        !details.url.startsWith(chrome.runtime.getURL(''))) {\n        var targetUrl_1 = details.url;\n        console.log(\"[Background-WebReq] Processing main_frame URL: \".concat(targetUrl_1));\n        (function () { return __awaiter(_this, void 0, void 0, function () {\n            var cachedEntry, result, scanCache, detectedRedirects, tabRedirectInfo, trustScore, alertMessage, geminiAiScore, geminiAiReason, fetchedResult, cacheEntry;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        cachedEntry = null;\n                        return [4 /*yield*/, chrome.storage.local.get(['scanCache', 'detectedRedirects'])];\n                    case 1:\n                        result = _a.sent();\n                        scanCache = result.scanCache || {};\n                        detectedRedirects = result.detectedRedirects || {};\n                        cachedEntry = scanCache[targetUrl_1];\n                        tabRedirectInfo = detectedRedirects[details.tabId] || null;\n                        if (!(cachedEntry && (Date.now() - cachedEntry.timestamp < SCAN_CACHE_DURATION_MS))) return [3 /*break*/, 2];\n                        console.log(\"[Background-WebReq] Using cached scan result for \".concat(targetUrl_1, \" (pre-load).\"));\n                        trustScore = cachedEntry.score;\n                        alertMessage = cachedEntry.message;\n                        geminiAiScore = cachedEntry.geminiAiScore;\n                        geminiAiReason = cachedEntry.geminiAiReason;\n                        return [3 /*break*/, 5];\n                    case 2: return [4 /*yield*/, fetchTrustScoreFromBackend(targetUrl_1, tabRedirectInfo === null || tabRedirectInfo === void 0 ? void 0 : tabRedirectInfo.redirectType)];\n                    case 3:\n                        fetchedResult = _a.sent();\n                        trustScore = fetchedResult.trustScore;\n                        alertMessage = fetchedResult.alertMessage;\n                        geminiAiScore = fetchedResult.geminiAiScore;\n                        geminiAiReason = fetchedResult.geminiAiReason;\n                        cacheEntry = {\n                            url: targetUrl_1,\n                            score: trustScore,\n                            message: alertMessage,\n                            tabId: details.tabId,\n                            timestamp: Date.now(),\n                            geminiAiScore: geminiAiScore,\n                            geminiAiReason: geminiAiReason\n                        };\n                        scanCache[targetUrl_1] = cacheEntry;\n                        return [4 /*yield*/, chrome.storage.local.set({ scanCache: scanCache })];\n                    case 4:\n                        _a.sent();\n                        console.log(\"[Background-WebReq] Cached new scan result for \".concat(targetUrl_1, \".\"));\n                        _a.label = 5;\n                    case 5:\n                        if (!tabRedirectInfo) return [3 /*break*/, 7];\n                        delete detectedRedirects[details.tabId];\n                        return [4 /*yield*/, chrome.storage.local.set({ detectedRedirects: detectedRedirects })];\n                    case 6:\n                        _a.sent();\n                        console.log(\"[Background-WebReq] Cleared redirect info for tab \".concat(details.tabId, \".\"));\n                        _a.label = 7;\n                    case 7: return [4 /*yield*/, chrome.storage.local.set({\n                            phisherShieldAlertData: {\n                                url: targetUrl_1,\n                                score: trustScore,\n                                message: alertMessage,\n                                tabId: details.tabId,\n                                geminiAiScore: geminiAiScore,\n                                geminiAiReason: geminiAiReason\n                            }\n                        })];\n                    case 8:\n                        _a.sent();\n                        console.log(\"[Background-WebReq] Stored alert data for overlay: \".concat(targetUrl_1, \".\"));\n                        if (!(trustScore < 50)) return [3 /*break*/, 10];\n                        console.log(\"[Background-WebReq] Score \".concat(trustScore, \" is suspicious. Sending message to tab \").concat(details.tabId, \" to display alert.\"));\n                        return [4 /*yield*/, retrySendMessage(details.tabId, { type: 'displayPhishingAlert' })];\n                    case 9:\n                        _a.sent();\n                        return [3 /*break*/, 12];\n                    case 10:\n                        console.log(\"[Background-WebReq] Score \".concat(trustScore, \" is safe. Allowing navigation for \").concat(targetUrl_1, \".\"));\n                        return [4 /*yield*/, retrySendMessage(details.tabId, { type: 'removePhishingAlert' }, 1)];\n                    case 11:\n                        _a.sent();\n                        _a.label = 12;\n                    case 12: return [2 /*return*/];\n                }\n            });\n        }); })();\n        return { cancel: false };\n    }\n    return { cancel: false };\n}, { urls: [\"<all_urls>\"], types: [\"main_frame\"] }, []);\n// Listener to clear the bypass flag once navigation has committed\nchrome.webNavigation.onCommitted.addListener(function (details) {\n    if (bypassingTabs.has(details.tabId) && details.frameId === 0) {\n        bypassingTabs.delete(details.tabId);\n        console.log(\"[Background-WebNav] Cleared bypass flag for tab \".concat(details.tabId, \" for URL: \").concat(details.url, \".\"));\n    }\n}, { url: [{ urlMatches: \"http://*/*\" }, { urlMatches: \"https://*/*\" }] });\n// Listener for messages coming FROM content script (user actions or detected redirects)\nchrome.runtime.onMessage.addListener(function (message, sender, sendResponse) { return __awaiter(void 0, void 0, void 0, function () {\n    var action, originalUrl, tabId, initialUrl_1, finalUrl_1, redirectType_1, tabId_1;\n    var _a, _b;\n    return __generator(this, function (_c) {\n        switch (_c.label) {\n            case 0:\n                if (!(message.type === \"userAction\")) return [3 /*break*/, 7];\n                action = message.action, originalUrl = message.originalUrl, tabId = message.tabId;\n                console.log(\"[Background] User action from alert overlay: \".concat(action, \" for \").concat(originalUrl, \" in tab \").concat(tabId));\n                if (!(action === \"continue\")) return [3 /*break*/, 2];\n                bypassingTabs.add(tabId);\n                return [4 /*yield*/, retrySendMessage(tabId, { type: 'removePhishingAlert' }, 1)];\n            case 1:\n                _c.sent();\n                console.log(\"[Background] Allowing interaction for \".concat(originalUrl, \".\"));\n                return [3 /*break*/, 6];\n            case 2:\n                if (!(action === \"report\")) return [3 /*break*/, 4];\n                bypassingTabs.add(tabId);\n                return [4 /*yield*/, retrySendMessage(tabId, { type: 'removePhishingAlert' }, 1)];\n            case 3:\n                _c.sent();\n                chrome.tabs.create({ url: \"http://localhost:3001/?url=\".concat(encodeURIComponent(originalUrl)) }); // FIXED URL\n                console.log(\"[Background] Opened report page for \".concat(originalUrl));\n                return [3 /*break*/, 6];\n            case 4:\n                if (!(action === \"block\")) return [3 /*break*/, 6];\n                bypassingTabs.add(tabId);\n                return [4 /*yield*/, retrySendMessage(tabId, { type: 'removePhishingAlert' }, 1)];\n            case 5:\n                _c.sent();\n                chrome.tabs.update(tabId, { url: \"about:blank\" });\n                console.log(\"[Background] Blocked navigation for \".concat(originalUrl, \".\"));\n                _c.label = 6;\n            case 6: return [3 /*break*/, 8];\n            case 7:\n                if (message.type === \"pageContent\") {\n                    console.log(\"[Background] Received page content from content script (Tab: \".concat((_a = sender.tab) === null || _a === void 0 ? void 0 : _a.id, \", URL: \").concat(message.url, \")\"));\n                }\n                else if (message.type === \"detectedRedirect\") {\n                    initialUrl_1 = message.initialUrl, finalUrl_1 = message.finalUrl, redirectType_1 = message.redirectType;\n                    tabId_1 = (_b = sender.tab) === null || _b === void 0 ? void 0 : _b.id;\n                    if (tabId_1) {\n                        console.log(\"[Background] Detected \".concat(redirectType_1, \" redirect from \").concat(initialUrl_1, \" to \").concat(finalUrl_1, \" in tab \").concat(tabId_1, \".\"));\n                        chrome.storage.local.get('detectedRedirects', function (result) { return __awaiter(void 0, void 0, void 0, function () {\n                            var detectedRedirects;\n                            return __generator(this, function (_a) {\n                                switch (_a.label) {\n                                    case 0:\n                                        detectedRedirects = result.detectedRedirects || {};\n                                        detectedRedirects[tabId_1] = {\n                                            initialUrl: initialUrl_1,\n                                            finalUrl: finalUrl_1,\n                                            redirectType: redirectType_1,\n                                            timestamp: Date.now()\n                                        };\n                                        return [4 /*yield*/, chrome.storage.local.set({ detectedRedirects: detectedRedirects })];\n                                    case 1:\n                                        _a.sent();\n                                        console.log(\"[Background] Stored redirect info for tab \".concat(tabId_1, \".\"));\n                                        return [2 /*return*/];\n                                }\n                            });\n                        }); });\n                    }\n                    else {\n                        console.warn(\"[Background] Received detectedRedirect message without a valid tabId.\");\n                    }\n                }\n                _c.label = 8;\n            case 8: return [2 /*return*/];\n        }\n    });\n}); });\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[\"./src/background.ts\"]();\n",""],"names":[],"sourceRoot":""}