{"version":3,"file":"dist/backgroundBundle.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AEtQA;AACA;AACA;AACA;AACA","sources":["webpack://phisher-shield-extension/./src/background.ts","webpack://phisher-shield-extension/webpack/before-startup","webpack://phisher-shield-extension/webpack/startup","webpack://phisher-shield-extension/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\n// extension/src/background.ts\nconsole.log('PhisherShield background service worker started (Corrected Message Listeners).');\n// Define a flag to indicate if we are navigating after a 'continue' action\nvar bypassingTabs = new Set();\n// Define cache duration (e.g., 5 minutes)\nvar SCAN_CACHE_DURATION_MS = 5 * 60 * 1000; // Cache results for 5 minutes (5 * 60 seconds * 1000 ms)\n// Helper function to fetch trust score from your backend\nfunction fetchTrustScoreFromBackend(url) {\n    return __awaiter(this, void 0, void 0, function () {\n        var response, errorText, data, error_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    _a.trys.push([0, 5, , 6]);\n                    console.log(\"[Background] Attempting to fetch trust score for: \".concat(url));\n                    return [4 /*yield*/, fetch(\"http://localhost:4000/api/trustScore\", {\n                            method: 'POST',\n                            headers: { 'Content-Type': 'application/json' },\n                            body: JSON.stringify({ url: url, content: '' }), // Send empty content for pre-load scan\n                        })];\n                case 1:\n                    response = _a.sent();\n                    if (!!response.ok) return [3 /*break*/, 3];\n                    return [4 /*yield*/, response.text()];\n                case 2:\n                    errorText = _a.sent();\n                    console.error(\"[Background] Backend HTTP error for \".concat(url, \": Status \").concat(response.status, \", Message: \").concat(errorText));\n                    return [2 /*return*/, { trustScore: 0, alertMessage: \"Failed to scan site: Server error.\" }];\n                case 3: return [4 /*yield*/, response.json()];\n                case 4:\n                    data = _a.sent();\n                    console.log(\"[Background] Successfully fetched score for \".concat(url, \":\"), data);\n                    return [2 /*return*/, { trustScore: data.trustScore, alertMessage: data.alertMessage }];\n                case 5:\n                    error_1 = _a.sent();\n                    console.error(\"[Background] Network error fetching trust score for \".concat(url, \":\"), error_1);\n                    return [2 /*return*/, { trustScore: 0, alertMessage: \"Failed to scan site: Network error.\" }];\n                case 6: return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * Attempts to send a message to a tab, retrying if 'Receiving end does not exist' error occurs.\n * @param tabId The ID of the target tab.\n * @param message The message object to send.\n * @param retries Remaining retry attempts.\n * @param delayMs Delay in milliseconds before next retry.\n */\nfunction retrySendMessage(tabId_1, message_1) {\n    return __awaiter(this, arguments, void 0, function (tabId, message, retries, delayMs) {\n        var error_2;\n        if (retries === void 0) { retries = 3; }\n        if (delayMs === void 0) { delayMs = 200; }\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    console.log(\"[Background] Attempting to send message to tab \".concat(tabId, \" (Type: \").concat(message.type, \", Retries left: \").concat(retries, \")\"));\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 3, , 8]);\n                    return [4 /*yield*/, chrome.tabs.sendMessage(tabId, message)];\n                case 2:\n                    _a.sent();\n                    console.log(\"[Background] Successfully sent message to tab \".concat(tabId, \" (Type: \").concat(message.type, \").\"));\n                    return [3 /*break*/, 8];\n                case 3:\n                    error_2 = _a.sent();\n                    if (!(error_2.message && error_2.message.includes('Receiving end does not exist') && retries > 0)) return [3 /*break*/, 6];\n                    console.warn(\"[Background] Retrying message to tab \".concat(tabId, \" (Type: \").concat(message.type, \")... Retries left: \").concat(retries - 1));\n                    return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, delayMs); })];\n                case 4:\n                    _a.sent(); // Wait before retrying\n                    return [4 /*yield*/, retrySendMessage(tabId, message, retries - 1, delayMs * 1.5)];\n                case 5:\n                    _a.sent(); // Exponential backoff\n                    return [3 /*break*/, 7];\n                case 6:\n                    console.error(\"[Background] Failed to send message to tab \".concat(tabId, \" (Type: \").concat(message.type, \"):\"), error_2);\n                    _a.label = 7;\n                case 7: return [3 /*break*/, 8];\n                case 8: return [2 /*return*/];\n            }\n        });\n    });\n}\n// Listener for URL navigation requests (the pre-load check)\nchrome.webRequest.onBeforeRequest.addListener(function (details) {\n    var _this = this;\n    console.log(\"[Background-WebReq] Intercepted: \".concat(details.url, \", Type: \").concat(details.type, \", TabId: \").concat(details.tabId));\n    if (bypassingTabs.has(details.tabId)) {\n        console.log(\"[Background-WebReq] Bypassing scan for tab \".concat(details.tabId, \" (original URL: \").concat(details.url, \") due to 'continue' action.\"));\n        return { cancel: false };\n    }\n    if (details.type === \"main_frame\" &&\n        (details.url.startsWith(\"http://\") || details.url.startsWith(\"https://\")) &&\n        !details.url.startsWith(chrome.runtime.getURL(''))) {\n        var targetUrl_1 = details.url;\n        console.log(\"[Background-WebReq] Processing main_frame URL: \".concat(targetUrl_1));\n        (function () { return __awaiter(_this, void 0, void 0, function () {\n            var cachedEntry, result, scanCache, trustScore, alertMessage, fetchedResult, cacheEntry;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        cachedEntry = null;\n                        return [4 /*yield*/, chrome.storage.local.get('scanCache')];\n                    case 1:\n                        result = _a.sent();\n                        scanCache = result.scanCache || {};\n                        cachedEntry = scanCache[targetUrl_1];\n                        if (!(cachedEntry && (Date.now() - cachedEntry.timestamp < SCAN_CACHE_DURATION_MS))) return [3 /*break*/, 2];\n                        console.log(\"[Background-WebReq] Using cached scan result for \".concat(targetUrl_1, \" (pre-load).\"));\n                        trustScore = cachedEntry.score;\n                        alertMessage = cachedEntry.message;\n                        return [3 /*break*/, 5];\n                    case 2: return [4 /*yield*/, fetchTrustScoreFromBackend(targetUrl_1)];\n                    case 3:\n                        fetchedResult = _a.sent();\n                        trustScore = fetchedResult.trustScore;\n                        alertMessage = fetchedResult.alertMessage;\n                        cacheEntry = {\n                            url: targetUrl_1,\n                            score: trustScore,\n                            message: alertMessage,\n                            tabId: details.tabId,\n                            timestamp: Date.now()\n                        };\n                        scanCache[targetUrl_1] = cacheEntry;\n                        return [4 /*yield*/, chrome.storage.local.set({ scanCache: scanCache })];\n                    case 4:\n                        _a.sent();\n                        console.log(\"[Background-WebReq] Cached new scan result for \".concat(targetUrl_1, \".\"));\n                        _a.label = 5;\n                    case 5: return [4 /*yield*/, chrome.storage.local.set({\n                            phisherShieldAlertData: {\n                                url: targetUrl_1,\n                                score: trustScore,\n                                message: alertMessage,\n                                tabId: details.tabId\n                            }\n                        })];\n                    case 6:\n                        _a.sent();\n                        console.log(\"[Background-WebReq] Stored alert data for overlay: \".concat(targetUrl_1, \".\"));\n                        if (!(trustScore < 50)) return [3 /*break*/, 8];\n                        console.log(\"[Background-WebReq] Score \".concat(trustScore, \" is suspicious. Sending message to tab \").concat(details.tabId, \" to display alert.\"));\n                        return [4 /*yield*/, retrySendMessage(details.tabId, { type: 'displayPhishingAlert' })];\n                    case 7:\n                        _a.sent();\n                        return [3 /*break*/, 10];\n                    case 8:\n                        console.log(\"[Background-WebReq] Score \".concat(trustScore, \" is safe. Allowing navigation for \").concat(targetUrl_1, \".\"));\n                        return [4 /*yield*/, retrySendMessage(details.tabId, { type: 'removePhishingAlert' }, 1)];\n                    case 9:\n                        _a.sent();\n                        _a.label = 10;\n                    case 10: return [2 /*return*/];\n                }\n            });\n        }); })();\n        return { cancel: false };\n    }\n    return { cancel: false };\n}, { urls: [\"<all_urls>\"], types: [\"main_frame\"] }, []);\n// Listener to clear the bypass flag once navigation has committed\nchrome.webNavigation.onCommitted.addListener(function (details) {\n    if (bypassingTabs.has(details.tabId) && details.frameId === 0) {\n        bypassingTabs.delete(details.tabId);\n        console.log(\"[Background-WebNav] Cleared bypass flag for tab \".concat(details.tabId, \" for URL: \").concat(details.url, \".\"));\n    }\n}, { url: [{ urlMatches: \"http://*/*\" }, { urlMatches: \"https://*/*\" }] });\n// --- CRITICAL FIX: Ensure only ONE chrome.runtime.onMessage.addListener ---\n// This listener handles all message types coming from the content script or popup.\nchrome.runtime.onMessage.addListener(function (message, sender, sendResponse) { return __awaiter(void 0, void 0, void 0, function () {\n    var action, originalUrl, tabId, initialUrl, finalUrl, redirectType;\n    var _a;\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0:\n                if (!(message.type === \"userAction\")) return [3 /*break*/, 7];\n                action = message.action, originalUrl = message.originalUrl, tabId = message.tabId;\n                console.log(\"[Background] User action from alert overlay: \".concat(action, \" for \").concat(originalUrl, \" in tab \").concat(tabId));\n                if (!(action === \"continue\")) return [3 /*break*/, 2];\n                bypassingTabs.add(tabId);\n                return [4 /*yield*/, retrySendMessage(tabId, { type: 'removePhishingAlert' }, 1)];\n            case 1:\n                _b.sent();\n                console.log(\"[Background] Allowing interaction for \".concat(originalUrl, \".\"));\n                return [3 /*break*/, 6];\n            case 2:\n                if (!(action === \"report\")) return [3 /*break*/, 4];\n                bypassingTabs.add(tabId);\n                return [4 /*yield*/, retrySendMessage(tabId, { type: 'removePhishingAlert' }, 1)];\n            case 3:\n                _b.sent();\n                chrome.tabs.create({ url: \"http://localhost:4000/report?url=\".concat(encodeURIComponent(originalUrl)) });\n                console.log(\"[Background] Opened report page for \".concat(originalUrl));\n                return [3 /*break*/, 6];\n            case 4:\n                if (!(action === \"block\")) return [3 /*break*/, 6];\n                bypassingTabs.add(tabId);\n                return [4 /*yield*/, retrySendMessage(tabId, { type: 'removePhishingAlert' }, 1)];\n            case 5:\n                _b.sent();\n                chrome.tabs.update(tabId, { url: \"about:blank\" });\n                console.log(\"[Background] Blocked navigation for \".concat(originalUrl, \".\"));\n                _b.label = 6;\n            case 6: return [3 /*break*/, 8];\n            case 7:\n                if (message.type === \"pageContent\") {\n                    console.log(\"[Background] Received page content from content script (Tab: \".concat((_a = sender.tab) === null || _a === void 0 ? void 0 : _a.id, \", URL: \").concat(message.url, \")\"));\n                }\n                else if (message.type === \"detectedRedirect\") { // <--- NEW MESSAGE TYPE: Handle detected redirects here\n                    initialUrl = message.initialUrl, finalUrl = message.finalUrl, redirectType = message.redirectType;\n                    console.log(\"[Background] Detected \".concat(redirectType, \" redirect from \").concat(initialUrl, \" to \").concat(finalUrl, \".\"));\n                    // Here, you would typically send this to your backend if you want to apply a deduction\n                    // or trigger a notification based on this redirect.\n                    // Example of sending to backend for analysis (you'd need to adapt fetchTrustScoreFromBackend):\n                    // const { trustScore, alertMessage } = await fetchTrustScoreFromBackend(finalUrl, { redirectDetected: true, redirectType });\n                    // You could then trigger a notification or a follow-up action.\n                }\n                _b.label = 8;\n            case 8: return [2 /*return*/];\n        }\n    });\n}); });\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = {};\n__webpack_modules__[\"./src/background.ts\"]();\n",""],"names":[],"sourceRoot":""}